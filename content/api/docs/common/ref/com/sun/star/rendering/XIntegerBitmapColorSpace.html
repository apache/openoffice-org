
<!--#include virtual="/doctype.html" -->
<html>
  <head>
    
    
<title>Interface XIntegerBitmapColorSpace</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../../../idl.css">

    
    <link href="/css/ooo.css" rel="stylesheet" type="text/css">
    <!--#include virtual="/scripts/google-analytics.js" --> 
    <!--#include virtual="/scripts/entourage.js" -->
  </head>
  <body>
    <!--#include virtual="/brand.html" -->
    <div id="topbara">
      <!--#include virtual="/topnav.html" -->
      <div id="breadcrumbsa"><a href="/">home</a>&nbsp;&raquo;&nbsp;<a href="/api/">api</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/">docs</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/">common</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/ref/">ref</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/ref/com/">com</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/ref/com/sun/">sun</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/ref/com/sun/star/">star</a>&nbsp;&raquo;&nbsp;<a href="/api/docs/common/ref/com/sun/star/rendering/">rendering</a></div>
    </div>
    <div id="clear"></div>
      <!--#include virtual="/api/leftnav.html" -->
      
    <div id="content">
      
      
<div id="adc-idlref">

<a name="_top_"> </a><table class="navimain" border="0" cellpadding="3">
<tr>
<td class="navimain"><a href="../module-ix.html" class="navimain">Overview</a></td>
<td class="navimain"><a href="module-ix.html" class="navimain">Module</a></td>
<td class="navimain"><a href="XIntegerBitmapColorSpace-xref.html" class="navimain">Use</a></td>
<td class="navimainnone">Devguide</td>
<td class="navimain"><a href="../../../../index-files/index-1.html" class="navimain">Index</a></td>
</tr>
</table>
<table class="navisub" border="0" cellpadding="0">
<tr>
<td class="navisub"><a href="#MethodsSummary" class="navisub">Methods' Summary</a></td>
<td class="navisub">Attributes' Summary</td>
<td class="navisub"><a href="#MethodsDetails" class="navisub">Methods' Details</a></td>
<td class="navisub">Attributes' Details</td>
</tr>
</table>
<hr>
<table border="0" width="100%" cellpadding="5" cellspacing="3" class="title-table" style="margin-bottom:6pt;">
<tr>
<td><p class="namechain"><a href="../../../../module-ix.html" class="namechain">::</a> <a href="../../../module-ix.html" class="namechain">com</a> :: <a href="../../module-ix.html" class="namechain">sun</a> :: <a href="../module-ix.html" class="namechain">star</a> :: <a href="module-ix.html" class="namechain">rendering</a> :: </p>
</td>
</tr>
<tr>
<td class="title"><table class="title-table" width="99%">
<tr>
<td width="25%" class="title2">unpublished </td>
<td width="50%" class="title">interface XIntegerBitmapColorSpace</td>
<td width="*"/></tr>
</table>
</td>
</tr>
<tr>
<td><dl>
<dt><b>Base Interfaces</b></dt>
<dd><pre style="font-family:monospace;"><strong>XIntegerBitmapColorSpace</strong>
&#x2517 <a href="XColorSpace.html">XColorSpace</a>

</pre></dd>
<dd><a name/><table border="1" width="100%" cellpadding="5" cellspacing="0" class="crosstitle">
<tr>
<td class="imsum_left"><a href="XColorSpace.html">XColorSpace</a></td>
<td class="imsum_right"><dl>
<dt>(referenced interface's summary:)</dt>
<dd>Information how to interpret certain color data.</dd>
</dl>
</td>
</tr>
</table>
</dd>
</dl>
</td>
</tr>
<tr>
<td><dl>
<dt><b>Usage Restrictions</b></dt>
<dd><i>not published</i></dd>
<dt><b>Description</b></dt>
<dd>A color space for integer bitmap formats</dd>
<dd><p>

 This interface encapsulates all information specific to a certain
 integer bitmap color space, like for example 1555 ARGB. Note that
 the individual elements of the integer color representation
 sequence need not correspond to the color space's components -
 instead, the color components might be packed back-to-back into
 those bytes, as they appear in the raw bitmap data.<p>
 </dd>
</dl>
</td>
</tr>
</table>
<hr>
<a name="MethodsSummary"/><table border="1" width="100%" cellpadding="5" cellspacing="0" class="subtitle">
<tr>
<td class="subtitle" colspan="2">Methods' Summary</td>
</tr>
<tr>
<td class="imsum_left"><a href="#getBitsPerPixel">getBitsPerPixel</a></td>
<td class="imsum_right">Query number of bits used per bitmap pixel.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#getComponentBitCounts">getComponentBitCounts</a></td>
<td class="imsum_right">Query the number of bits used for each component.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#getEndianness">getEndianness</a></td>
<td class="imsum_right">Query whether color data bytes need to be swapped.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertFromIntegerColorSpace">convertFromIntegerColorSpace</a></td>
<td class="imsum_right">Convert integer bitmap color to generic IEEE double device
 color of another color space.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertToIntegerColorSpace">convertToIntegerColorSpace</a></td>
<td class="imsum_right">Convert integer bitmap color to integer bitmap color of
 another integer bitmap color space.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerToRGB">convertIntegerToRGB</a></td>
<td class="imsum_right">Convert color value in this color space to sRGB color values.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerToARGB">convertIntegerToARGB</a></td>
<td class="imsum_right">Convert color value in this color space to sRGB color values,
 with linear alpha.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerToPARGB">convertIntegerToPARGB</a></td>
<td class="imsum_right">Convert color value in this color space to premultiplied sRGB
 color values, with linear alpha.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerFromRGB">convertIntegerFromRGB</a></td>
<td class="imsum_right">Convert sRGB color to an integer representation in this color
 space.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerFromARGB">convertIntegerFromARGB</a></td>
<td class="imsum_right">Convert sRGB color with linear alpha into this color space.&nbsp;</td>
</tr>
<tr>
<td class="imsum_left"><a href="#convertIntegerFromPARGB">convertIntegerFromPARGB</a></td>
<td class="imsum_right">Convert premultiplied sRGB color with linear alpha into this
 color space.&nbsp;</td>
</tr>
</table>
<a name="MethodsDetails"/><table border="1" width="100%" cellpadding="5" cellspacing="0" class="subtitle">
<tr>
<td class="subtitle">Methods' Details</td>
</tr>
<tr>
<td class="imdetail"><a name="getBitsPerPixel" class="membertitle">getBitsPerPixel</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">long</td>
</tr>
<tr>
<td valign="top"><b>getBitsPerPixel</b>();</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Query number of bits used per bitmap pixel.</dd>
<dd><p>

 This method yields the total number of bits used for a color
 value. At the associated <a href="XIntegerBitmap.html">XIntegerBitmap</a>, the
 <a href="XIntegerBitmap.html">XIntegerBitmap</a>::<a href="XIntegerBitmap.html#setPixel">setPixel()</a> method will expect
 a sequence of ceil(BitsPerPixel/8) bytes, and the
 <a href="XIntegerReadOnlyBitmap.html">XIntegerReadOnlyBitmap</a>::<a href="XIntegerReadOnlyBitmap.html#getPixel">getPixel()</a> will
 return that number of bytes. Similarly, the color conversion
 expect input data in multiples of ceil(BitsPerPixel/8), and
 also return converted data in chunks of this.<p>
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="getComponentBitCounts" class="membertitle">getComponentBitCounts</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; long &gt;</td>
</tr>
<tr>
<td valign="top"><b>getComponentBitCounts</b>();</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Query the number of bits used for each component.</dd>
<dd><p>

 This method returnes a sequence of integers, each denoting the
 number of bits occupied by the respective component. The sum
 of all component bits must be less or equal than the value
 returned from <a href="#getBitsPerPixel()">getBitsPerPixel()</a>. If the sum is
 less, excess bits are always kept in the most significant bits
 of a pixel. Color components will appear in the byte sequences
 returned from the <a href="XIntegerBitmap.html">XIntegerBitmap</a> methods in the
 order defined here, with the first element starting from the
 least significant bits of the pixel, etc.<p>

 </dd>
<dt><b>Example</b></dt>
<dd>For the typical 32 bit RGBA color data, the four
 values would all contain the value eight. For a 16 bit 1555
 ARGB format, with mask values 0x8000 for alpha, 0x7C for red,
 0x3E for green and 0x1F for blue, the values would be 5, 5, 5,
 1, in that order.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="getEndianness" class="membertitle">getEndianness</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">byte</td>
</tr>
<tr>
<td valign="top"><b>getEndianness</b>();</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Query whether color data bytes need to be swapped.</dd>
<dd><p>

 </dd>
<dt><b>Returns</b></dt>
<dd><b>true</b>, This method returns the endiannes of the color
 data. The value is one of the ::Endianness
 constants. If color data is represented using more than one
 byte, the actual channel positions are specified using bit
 positions. Therefore, depending on the architecture, the
 actual color data bytes might need to get swapped, for the
 bits to align properly.<p>

 </dd>
<dt><b>Example</b></dt>
<dd>with a 16 bit 565 RGB format, written on a big endian
 architecture, a destination machine using little endian CPU
 will need to swap the bytes, in order to keep the green
 channel bits together.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertFromIntegerColorSpace" class="membertitle">convertFromIntegerColorSpace</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; <a href="ColorComponent.html">ColorComponent</a> &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertFromIntegerColorSpace</b>(</td>
<td valign="top">[in] sequence&lt; byte &gt;</td>
<td valign="bottom">&nbsp;deviceColor,</td>
</tr>
<tr>
<td/><td valign="top">[in] <a href="XColorSpace.html">XColorSpace</a></td>
<td valign="bottom">&nbsp;targetColorSpace )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert integer bitmap color to generic IEEE double device
 color of another color space.</dd>
<dd><p>

 Color values are properly rounded and clipped, to be valid in
 the target color space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of device color components. Is
 permitted to contain more than one device color element,
 therefore, batch conversion of multiple color values is
 possible.<p>

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of device colors in the
 target color space

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertToIntegerColorSpace" class="membertitle">convertToIntegerColorSpace</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; byte &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertToIntegerColorSpace</b>(</td>
<td valign="top">[in] sequence&lt; byte &gt;</td>
<td valign="bottom">&nbsp;deviceColor,</td>
</tr>
<tr>
<td/><td valign="top">[in] <a href="XIntegerBitmapColorSpace.html">XIntegerBitmapColorSpace</a></td>
<td valign="bottom">&nbsp;targetColorSpace )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert integer bitmap color to integer bitmap color of
 another integer bitmap color space.</dd>
<dd><p>

 Color values are properly rounded and clipped, to be valid in
 the target color space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of device color components. Is
 permitted to contain more than one device color element,
 therefore, batch conversion of multiple color values is
 possible.<p>

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of device colors in the
 target color space

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerToRGB" class="membertitle">convertIntegerToRGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; <a href="RGBColor.html">RGBColor</a> &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerToRGB</b>(</td>
<td valign="top">[in] sequence&lt; byte &gt;</td>
<td valign="bottom">&nbsp;deviceColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert color value in this color space to sRGB color values.</dd>
<dd><p>

 Any information not representable in the <a href="RGBColor.html">RGBColor</a>
 struct is discarded during the conversion. This includes alpha
 information. Color values are properly rounded and clipped,
 to be valid in the target color space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of device color components. Is
 permitted to contain more than one device color element,
 therefore, batch conversion of multiple color values is
 possible.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of sRGB colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
<dt><b>See also</b></dt>
<dd><a href="XIntegerBitmapColorSpace.html">XIntegerBitmapColorSpace</a>::<a href="XIntegerBitmapColorSpace.html#convertIntegerToARGB">convertIntegerToARGB</a></dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerToARGB" class="membertitle">convertIntegerToARGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; <a href="ARGBColor.html">ARGBColor</a> &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerToARGB</b>(</td>
<td valign="top">[in] sequence&lt; byte &gt;</td>
<td valign="bottom">&nbsp;deviceColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert color value in this color space to sRGB color values,
 with linear alpha.</dd>
<dd><p>

 If the given input color does not carry alpha information, an
 alpha value of 1.0 (fully opaque) is assumed. Color values
 are properly rounded and clipped, to be valid in the target
 color space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of device color components. Is
 permitted to contain more than one device color element,
 therefore, batch conversion of multiple color values is
 possible.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of sRGB colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerToPARGB" class="membertitle">convertIntegerToPARGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; <a href="ARGBColor.html">ARGBColor</a> &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerToPARGB</b>(</td>
<td valign="top">[in] sequence&lt; byte &gt;</td>
<td valign="bottom">&nbsp;deviceColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert color value in this color space to premultiplied sRGB
 color values, with linear alpha.</dd>
<dd><p>

 If the given input color does not carry alpha information, an
 alpha value of 1.0 (fully opaque) is assumed. Color values
 are properly rounded and clipped, to be valid in the target
 color space. The resulting individual RGB color values are
 premultiplied by the alpha value (e.g. if alpha is 0.5, each
 color value has only half of the original intensity).<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of device color components. Is
 permitted to contain more than one device color element,
 therefore, batch conversion of multiple color values is
 possible.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of sRGB colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerFromRGB" class="membertitle">convertIntegerFromRGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; byte &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerFromRGB</b>(</td>
<td valign="top">[in] sequence&lt; <a href="RGBColor.html">RGBColor</a> &gt;</td>
<td valign="bottom">&nbsp;rgbColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert sRGB color to an integer representation in this color
 space.</dd>
<dd><p>

 If this color space conveys alpha information, it is assumed
 be fully opaque for the given rgb color value. Color values
 are properly rounded and clipped, to be valid in the target
 color space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of sRGB color components. Is
 permitted to contain more than one color element, therefore,
 batch conversion of multiple color values is possible.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of device colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerFromARGB" class="membertitle">convertIntegerFromARGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; byte &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerFromARGB</b>(</td>
<td valign="top">[in] sequence&lt; <a href="ARGBColor.html">ARGBColor</a> &gt;</td>
<td valign="bottom">&nbsp;rgbColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert sRGB color with linear alpha into this color space.</dd>
<dd><p>

 If this color space does not convey alpha information, the
 specified alpha value is silently ignored. Color values are
 properly rounded and clipped, to be valid in the target color
 space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of sRGB color components. Is
 permitted to contain more than one color element, therefore,
 batch conversion of multiple color values is possible.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of device colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class="imdetail"><a name="convertIntegerFromPARGB" class="membertitle">convertIntegerFromPARGB</a><table border="0" width="96%" cellpadding="5" cellspacing="0" class="table-in-method" bgcolor="#ffffff" align="center">
<tr>
<td><table class="table-in-method" border="0">
<tr>
<td valign="top" colspan="3">sequence&lt; byte &gt;</td>
</tr>
<tr>
<td valign="top"><b>convertIntegerFromPARGB</b>(</td>
<td valign="top">[in] sequence&lt; <a href="ARGBColor.html">ARGBColor</a> &gt;</td>
<td valign="bottom">&nbsp;rgbColor )</td>
</tr>
<tr>
<td valign="top" align="right">raises( </td>
<td valign="top" colspan="2">::com::sun::star::<a href="../lang/module-ix.html">lang</a>::<a href="../lang/IllegalArgumentException.html">IllegalArgumentException</a> );</td>
</tr>
</table>
<hr>
<dl>
<dt><b>Description</b></dt>
<dd>Convert premultiplied sRGB color with linear alpha into this
 color space.</dd>
<dd><p>

 If this color space does not convey alpha information, the
 specified alpha value is silently ignored. Color values are
 properly rounded and clipped, to be valid in the target color
 space.<p>

 </dd>
<dt><b>Parameter deviceColor</b></dt>
<dd>Sequence of sRGB color components. Is
 permitted to contain more than one color element, therefore,
 batch conversion of multiple color values is possible. The
 individual RGB color values are assumed to be premultiplied by
 the alpha value already.

 </dd>
<dt><b>Returns</b></dt>
<dd>the corresponding sequence of device colors.

 </dd>
<dt><b>Throws</b></dt>
<dd>a
 com::sun::star::lang::IllegalArgumentException,
 if the input sequence does not match the device color format.
 </dd>
</dl>
</td>
</tr>
</table>
</td>
</tr>
</table>
<a href="#_top_">Top of Page</a><hr size="3"><p class="copyright" align="center">Copyright &copy; 2013, The Apache Software Foundation, Licensed under the Apache License, Version 2.0. Apache, the Apache feather logo, Apache OpenOffice and OpenOffice.org are trademarks of The Apache Software Foundation. Other names may be trademarks of their respective owners.</p>

</div> <!-- id="adc-idlref" -->

      
    </div>
    <!--#include virtual="/footer.html" -->
  </body>
</html>

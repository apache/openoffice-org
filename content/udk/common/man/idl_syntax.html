<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<head>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>Unoidl syntax description</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.2 (Win32)">
	<META NAME="CLASSIFICATION" CONTENT="Unoidl syntax description">
	<META NAME="KEYWORDS" CONTENT="UNO,Unoidl,syntax,description">
</head>
<body LINK="#444488" VLINK="#444488" BGCOLOR="#eeeeff">
<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0 STYLE="page-break-before: always">
	<COL WIDTH=75>
	<TR>
		<TD BGCOLOR="#666699">
			<H1 ALIGN=CENTER STYLE="margin-top: 0cm; text-decoration: none"><A HREF="http://www.openoffice.org/"><IMG SRC="../../images/open_office_org_logo.gif" NAME="Grafik1" ALT="OpenOffice" ALIGN=RIGHT WIDTH=109 HEIGHT=54 BORDER=0></A><FONT COLOR="#ffffff"><FONT SIZE=6>Unoidl
			syntax description</FONT></FONT></H1>
		</TD>
	</TR>
</TABLE>
<HR SIZE=3 noshade>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
  <COL WIDTH=61*> <COL WIDTH=162*> <COL WIDTH=32*> 
  <TR> 
    <TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699"> 
      <H3 ALIGN=LEFT STYLE="margin-top: 0cm; text-decoration: none"><FONT COLOR="#ffffff"><FONT SIZE=4>Contents</FONT></FONT></H3>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
      <p><A HREF="#Introduction">Introduction</A><BR>
        <A HREF="#Keywords">Keywords</A><BR>
        <A HREF="#Array">Basetypes<br>
        </A> <A HREF="#Comments">Comments</A> <A HREF="#Array"><br>
        Array </A><br>
        <a href="#Union">Union</a> </p>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699"> 
      <H3 ALIGN=LEFT STYLE="margin-top: 0cm; text-decoration: none"><A NAME="Introduction"></A> 
        <FONT COLOR="#ffffff"><FONT SIZE=4>Introduction</FONT></FONT></H3>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
	<P>The unoidl is an idl language (interface description language) which is
	similar to the corba idl. Idl is a language to describe interfaces and
	types independently of any programming language and hardware platform.  An
	idl description is used by the idl compiler to generate code for these
	interfaces in a selected target language. The generated code provides the
	use of the described interfaces in the selected target language. The
	mapping of the idl description to the target language was defined in an
	appropriate language binding. </P>
	<P>All possible idl definitions will be described now. The reader who is
	intimate in C++ programming will see, that the syntax of the idl is similar
	to the C++ syntax. Because the lexical conventions of the idl and the
	structure of the definitions have a large degree with the ANSI standard for
	C++.</P>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699"> 
      <H3><A NAME="Keywords"></A><FONT COLOR="#ffffff">Keywords</FONT></H3>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
      <P>The following table shows all keywords of the unoidl. All the keywords 
        are reserved and cannot be used as an identifier.</P>
      <TABLE WIDTH=100% BORDER=1 CELLPADDING=4 CELLSPACING=0>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%><b>any</b></TD>
          <TD WIDTH=17%><b>attribute</b></TD>
          <TD WIDTH=17%><b>boolean</b></TD>
          <TD WIDTH=17%><b>bound</b></TD>
          <TD WIDTH=17%><b>byte</b></TD>
          <TD WIDTH=17%><b>case</b></TD>
        </TR>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%><b>char</b></TD>
          <TD WIDTH=17%><b>const</b></TD>
          <TD WIDTH=17%><b>constants</b></TD>
          <TD WIDTH=17%><b>constrained</b></TD>
          <TD WIDTH=17%><b>default</b></TD>
          <TD WIDTH=17%><b>double</b></TD>
        </TR>
        <COL WIDTH=43*> <COL WIDTH=43*> <COL WIDTH=43*> <COL WIDTH=43*> <COL WIDTH=43*> 
        <COL WIDTH=43*> 
        <TR VALIGN=TOP> 
          <TD WIDTH=17%> 
            <P><b>enum</b></P>
          </TD>
          <TD WIDTH=17%><b>exception</b></TD>
          <TD WIDTH=17%><b>float</b></TD>
          <TD WIDTH=17%> 
            <P><b>hyper</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P><b>in</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P><b>inout</b></P>
          </TD>
        </TR>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%> 
            <P><b>interface</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P><b>long</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P ALIGN=LEFT><b>maybeambigious</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P ALIGN=LEFT><b>maybedefault</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P><b>maybevoid</b></P>
          </TD>
          <TD WIDTH=17%> 
            <P><b>module</b></P>
          </TD>
        </TR>
        <tr valign=TOP> 
          <td width=17%> 
            <p><b>needs</b></p>
          </td>
          <td width=17%> 
            <p><b>observes</b></p>
          </td>
          <td width=17%> 
            <p><b>oneway</b></p>
          </td>
          <td width=17%> 
            <p><b>optional</b></p>
          </td>
          <td width=17%> 
            <p><b>out</b></p>
          </td>
          <td width=17%> 
            <p><b>property</b></p>
          </td>
        </tr>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%><b>raises</b></TD>
          <TD WIDTH=17%><b>readonly</b></TD>
          <TD WIDTH=17%><b>removable</b></TD>
          <TD WIDTH=17%><b>sequence</b></TD>
          <TD WIDTH=17%><b>service</b></TD>
          <TD WIDTH=17%><b>short</b></TD>
        </TR>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%><b>string</b></TD>
          <TD WIDTH=17%><b>struct</b></TD>
          <TD WIDTH=17%><b>switch</b></TD>
          <TD WIDTH=17%><b>transient</b></TD>
          <TD WIDTH=17%><b>type</b></TD>
          <TD WIDTH=17%><b>typedef</b></TD>
        </TR>
        <tr valign=TOP> 
          <td width=17%><b>union</b></td>
          <td width=17%><b>unsigned</b></td>
          <td width=17%><b>void</b></td>
          <td width=17%><b>FALSE</b></td>
          <td width=17%><b>False</b></td>
          <td width=17%><b>TRUE</b></td>
        </tr>
        <TR VALIGN=TOP> 
          <TD WIDTH=17%><b>True</b></TD>
          <TD WIDTH=17%>&nbsp;</TD>
          <TD WIDTH=17%>&nbsp;</TD>
          <TD WIDTH=17%>&nbsp;</TD>
          <TD WIDTH=17%>&nbsp;</TD>
          <TD WIDTH=17%>&nbsp;</TD>
        </TR>
      </TABLE>
      <BR>
      </TD>
  </TR>
  <tr> 
    <td colspan=3 width=100% bgcolor="#666699"> 
      <h3><a name="IDL_Specification"></a><font color="#FFFFFF">IDL language specification</font></h3>
    </td>
  </tr>
  <tr> 
    <td colspan=3 width=100%> 
      <p><i>Definition:</i></p>
      <pre>
<b><a name="1"></a><font color="#FF0000">(1)</font> &lt;idl_specification&gt; := &lt;definition&gt;+

<a name="2"></a><font color="#FF0000">(2)</font> &lt;definition&gt; := &lt;type_decl&gt; &quot;;&quot;
                    | &lt;module_decl&gt; &quot;;&quot;
                    | &lt;constant_decl&gt; &quot;;&quot;
                    | &lt;exception_decl&gt; &quot;;&quot;
                    | &lt;constants_decl&gt; &quot;;&quot;
                    | &lt;service_decl&gt; &quot;;&quot;

<font color="#FF0000"><a name="3"></a>(3)</font> &lt;type_decl&gt; := &lt;interface&gt;
                   | &lt;struct_decl&gt;
                   | &lt;enum_decl&gt;
                   | &lt;union_decl&gt;
                   | &quot;typedef&quot; &lt;type_spec&gt; &lt;declarator&gt; {&quot;,&quot; &lt;declarator&gt; }* 

<a name="4"></a><font color="#FF0000">(4)</font> &lt;interface&gt; := &lt;interface_decl&gt;
                   | &lt;forward_decl&gt;

<font color="#FF0000"><a name="5"></a>(5)</font> &lt;forward_decl&gt; := &quot;interface&quot; &lt;identifier&gt;

<font color="#FF0000"><a name="6"></a>(6)</font> &lt;interface_decl&gt; := &lt;interface_header&gt; &quot;{&quot; &lt;interface_body&gt; &quot;}&quot;

<font color="#FF0000"><a name="7"></a>(7)</font> &lt;interface_header&gt; := &quot;interface&quot; &lt;identifier&gt; [ &lt;interface_inheritance&gt; ]

<font color="#FF0000"><a name="8"></a>(8)</font> &lt;interface_inheritance&gt; := &quot;:&quot; &lt;interface_name&gt;

<font color="#FF0000"><a name="9"></a>(9)</font> &lt;interface_name&gt; := &lt;scoped_name&gt;

<font color="#FF0000"><a name="10"></a>(10)</font> &lt;scoped_name&gt; := &lt;identifier&gt;
                      | &quot;::&quot; &lt;scoped_name&gt;
                      | &lt;scoped_name&gt; &quot;::&quot; &lt;identifier&gt;

<font color="#FF0000"><a name="11"></a>(11)</font> &lt;interface_body&gt; := &lt;export&gt;+

<font color="#FF0000"><a name="12"></a>(12)</font> &lt;export&gt; := &lt;attribute_decl&gt; &quot;;&quot;
                 | &lt;operation_decl&gt; &quot;;&quot;

<font color="#FF0000"><a name="13"></a>(13)</font> &lt;attribute_decl&gt; := &lt;attribute_head&gt; &lt;type_spec&gt; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="14"></a>(14)</font> &lt;attribute_head&gt; := &quot;[&quot; [&quot;readonly&quot; &quot;,&quot;] &quot;attribute&quot; &quot;]&quot;
                         | &quot;[&quot; &quot;attribute&quot; [&quot;,&quot; &quot;readonly&quot;] &quot;]&quot;


<font color="#FF0000"><a name="15"></a>(15)</font> &lt;declarator&gt; := &lt;identifier&gt;
                     | &lt;array_declarator&gt; 

<font color="#FF0000"><a name="16"></a>(16)</font> &lt;array_declarator&gt; := &lt;identifier&gt; &lt;array_size&gt;+

<font color="#FF0000"><a name="17"></a>(17)</font> &lt;array_size&gt; := &quot;[&quot; &lt;positive_int&gt; &quot;]&quot;

<font color="#FF0000"><a name="18"></a>(18)</font> &lt;positive_int&gt; := &lt;const_expr&gt;

<font color="#FF0000"><a name="19"></a>(19)</font> &lt;type_spec&gt; := &lt;simple_type_spec&gt;
                    | constr_type_spec&gt;

<font color="#FF0000"><a name="20"></a>(20)</font> &lt;simple_type_spec&gt; := &lt;base_type_spec&gt;
                           | &lt;template_type_spec&gt;
                           | &lt;scoped_name&gt;

<font color="#FF0000"><a name="21"></a>(21)</font> &lt;base_type_spec&gt; := &lt;integer_type&gt;
                         | &lt;floating_point_type&gt;
                         | &lt;char_type&gt;
                         | &lt;byte_type&gt;  
                         | &lt;boolean_type&gt;
                         | &lt;string_type&gt;
                         | &lt;any_type&gt;
                         | &lt;type_type&gt;

<font color="#FF0000"><a name="22"></a>(22)</font> &lt;template_type&gt; := &lt;sequence_type&gt;
                        | &lt;array_type&gt;

<font color="#FF0000"><a name="23"></a>(23)</font> &lt;sequence_type&gt; := &quot;sequence&quot; &quot;&lt;&quot; &lt;type_spec&gt; &quot;&gt;&quot;

<font color="#FF0000"><a name="24"></a>(24)</font> &lt;array_type&gt; := &lt;type_spec&gt; &lt;array_size&gt;+

<font color="#FF0000"><a name="25"></a>(25)</font> &lt;floating_point_type&gt; := &quot;float&quot;
                              | &quot;double&quot;

<font color="#FF0000"><a name="26"></a>(26)</font> &lt;integer_type&gt; := &lt;signed_int&gt;
                       | &lt;unsinged_int&gt;

<font color="#FF0000"><a name="27"></a>(27)</font> &lt;signed_int&gt; := &quot;short&quot;
                     | &quot;long&quot;
                     | &quot;hyper&quot;


<font color="#FF0000"><a name="28"></a>(28)</font> &lt;unsigned_int&gt; := &quot;unsigned&quot; &quot;short&quot;
                       | &quot;unsigned&quot; &quot;long&quot;
                       | &quot;unsigned&quot; &quot;hyper&quot;

<font color="#FF0000"><a name="29"></a>(29)</font> &lt;char_type&gt; := &quot;char&quot;

<font color="#FF0000"><a name="30"></a>(30)</font> &lt;type_type&gt; := &quot;type&quot;

<font color="#FF0000"><a name="31"></a>(31)</font> &lt;string_type&gt; := &quot;string&quot;

<font color="#FF0000"><a name="32"></a>(32)</font> &lt;byte_type&gt; := &quot;byte&quot;

<font color="#FF0000"><a name="33"></a>(33)</font> &lt;any_type&quot; := &quot;any&quot;

<font color="#FF0000"><a name="34"></a>(34)</font> &lt;boolean_type&gt; := &quot;boolean&quot;

<font color="#FF0000"><a name="35"></a>(35)</font> &lt;constr_type_spec&gt; := &lt;struct_type&gt;
                           | &lt;enum_type&gt;
                           | &lt;union_type&gt;

<font color="#FF0000"><a name="36"></a>(36)</font> &lt;struct_type&gt; := &quot;struct&quot; &lt;identifier&gt; [ &lt;struct_inheritance&gt; ] &quot;{&quot; &lt;member&gt;+ &quot;}&quot;

<font color="#FF0000"><a name="37"></a>(37)</font> &lt;struct_inheritance&gt; := &quot;:&quot; &lt;scoped_name&gt;
 
<font color="#FF0000"><a name="38"></a>(38)</font> &lt;member&gt; := &lt;type_spec&gt; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="39"></a>(39)</font> enum_type&gt; := enum &lt;identifier&gt; &quot;{&quot; &lt;enumerator&gt; { &quot;,&quot; &lt;enumerator&gt; }* &quot;}&quot;

<font color="#FF0000"><a name="40"></a>(40)</font> &lt;enumerator&gt; := &lt;identifier&gt; [ &quot;=&quot; &lt;positive_int&gt; ]
 
<font color="#FF0000"><a name="41"></a>(41)</font> &lt;union_type&gt; := &quot;union&quot; &lt;identifier&gt; &quot;switch&quot; &quot;(&quot; &lt;switch_type_spec&gt; &quot;)&quot;
                       &quot;{&quot; &lt;switch_body&gt; &quot;}&quot;    
  
<font color="#FF0000"><a name="42"></a>(42)</font> &lt;switch_type_spec&gt; := &lt;integer_type&gt;
                           | &lt;enum_type&gt;
                           | &lt;scoped_name&gt; 

<font color="#FF0000"><a name="43"></a>(43)</font> &lt;switch_body&gt; := &lt;case&gt;+

<font color="#FF0000"><a name="44"></a>(44)</font> &lt;case&gt; := &lt;case_label&gt; &lt;element_spec&gt; &quot;;&quot;

<font color="#FF0000"><a name="45"></a>(45)</font> &lt;case_label&gt; := &quot;case&quot; &lt;const_expr&gt; &quot;:&quot; 
                     | &quot;default&quot; &quot;:&quot;;

<font color="#FF0000"><a name="46"></a>(46)</font> &lt;element_spec&gt; := &lt;type_spec&gt; &lt;declarator&gt;

<font color="#FF0000"><a name="47"></a>(47)</font> &lt;exception_decl&gt; := &quot;exception&quot; &lt;identifier&gt; [ &lt;exception_inheritance&gt; ] &quot;{&quot; &lt;member&gt;* &quot;}&quot;

<font color="#FF0000"><a name="48"></a>(48)</font> &lt;exception_inheritance&gt; := &quot;:&quot; &lt;scoped_name&gt;
 
<font color="#FF0000"><a name="49"></a>(49)</font> &lt;module_decl&gt; := &quot;module&quot; &lt;identifier&gt; &quot;{&quot; &lt;definition&gt;+ &quot;}&quot;

<font color="#FF0000"><a name="50"></a>(50)</font> &lt;constant_decl&gt; := &quot;const&quot; &lt;const_type&gt; &lt;identifier&gt; &quot;=&quot; &lt;const_expr&gt;

<font color="#FF0000"><a name="51"></a>(51)</font> &lt;const_type&gt; := &lt;integer_type&gt;
                     | &lt;char_type&gt;
                     | &lt;boolean_type&gt;
                     | &lt;floating_point_type&gt;  
                     | &lt;string_type&gt;
                     | &lt;scoped_name&gt;

<font color="#FF0000"><a name="52"></a>(52)</font> &lt;const_expr&gt; := &lt;or_expr&gt;

<font color="#FF0000"><a name="53"></a>(53)</font> &lt;or_expr&gt; := &lt;xor_expr&gt;
                  | &lt;or_expr&gt; &quot;|&quot; &lt;xor_expr&gt;

<font color="#FF0000"><a name="54"></a>(54)</font> &lt;xor_expr&gt; := &lt;and_expr&gt;<br>                   | &lt;xor_expr&gt; &quot;^&quot; &lt;and_expr&gt;

<font color="#FF0000"><a name="55"></a>(55)</font> &lt;and_expr&gt; := &lt;shift_expr&gt;
                   | &lt;and_expr&gt; &quot;&amp;&quot; &lt;shift_expr&gt;

<font color="#FF0000"><a name="56"></a>(56)</font> &lt;shift_expr&gt; := &lt;add_Expr&gt;
                     | &lt;shift_expr &quot;&gt;&gt;&quot; &lt;add_expr&gt;
                     | &lt;shift_expr &quot;&lt;&lt;&quot; &lt;add_expr&gt;

<font color="#FF0000"><a name="57"></a>(57)</font> &lt;add_expr&gt; := &lt;mult_expr&gt;
                   | &lt;add_expr&gt; &quot;+&quot; &lt;mult_expr&gt;
                   | &lt;add_expr&gt; &quot;-&quot; &lt;mult_expr&gt;

<font color="#FF0000"><a name="58"></a>(58)</font> &lt;mult_Expr&gt; := &lt;unary_expr&gt;
                    | &lt;mult_expr&gt; &quot;*&quot; &lt;unary_expr&gt;
                    | &lt;mult_expr&gt; &quot;/&quot; &lt;unary_expr&gt;
                    | &lt;mult_expr&gt; &quot;%&quot; &lt;unary_expr&gt;

<font color="#FF0000"><a name="59"></a>(59)</font> &lt;unary_expr&gt; := &lt;unary_operator&gt;&lt;primary_expr&gt;
                     | &lt;primary_expr&gt;

<font color="#FF0000"><a name="60"></a>(60)</font> &lt;unary_operator&gt; := &quot;-&quot; | &quot;+&quot; | &quot;~&quot;

<font color="#FF0000"><a name="61"></a>(61)</font> &lt;primary_expr&gt; := &lt;scoped_name&gt;
                       | &lt;literal&gt;
                       | &quot;(&quot; &lt;const_expr&gt; &quot;)&quot;

<font color="#FF0000"><a name="62"></a>(62)</font> &lt;literal&gt; := &lt;integer_literal&gt;
                  | &lt;string_literal&gt;
                  | &lt;character_literal&gt;
                  | &lt;floating_point_literal&gt;
                  | &lt;boolean_literal&gt;

<font color="#FF0000"><a name="63"></a>(63)</font> &lt;boolean_literal&gt; := &quot;TRUE&quot;
                          | &quot;True&quot;
                          | &quot;FALSE&quot;
                          | &quot;False&quot;
<font color="#FF0000"><a name="64"></a>(64)</font> &lt;service_decl&gt; := &quot;service&quot; &lt;identifier&gt; &quot;{&quot; &lt;service_member&gt;+ &quot;}&quot;

<font color="#FF0000"><a name="65"></a>(65)</font> &lt;service_member&gt; := &lt;property_decl&gt; &quot;;&quot;
                         | &lt;support_decl&gt; &quot;;&quot;
                         | &lt;export_decl&gt; &quot;;&quot;
                         | &lt;observe_decl&gt; &quot;;&quot;
                         | &lt;needs_decl&gt; &quot;;&quot;

<font color="#FF0000"><a name="66"></a>(66)</font> &lt;property_decl&gt; := &lt;property_head&gt; &lt;type_spec&gt; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="67"></a>(67)</font> &lt;property_head&gt; := &quot;[&quot; {&lt;property_flags&gt; &quot;,&quot;}* &quot;property&quot; &quot;]&quot;
                         | &quot;[&quot; &quot;property&quot; {&quot;,&quot; &lt;property_flags&gt;}* &quot;]&quot; 

<font color="#FF0000"><a name="68"></a>(68)</font> &lt;property_flags&gt; := &quot;readonly&quot;
                        | &quot;bound
                        | &quot;constrained&quot;
                        | &quot;maybeambigious&quot;
                        | &quot;maybedefault&quot;
                        | &quot;maybevoid&quot;
                        | &quot;optional&quot;
                        | &quot;removable&quot;
                        | &quot;transient&quot;
 
<font color="#FF0000"><a name="69"></a>(69)</font> &lt;support_decl&gt; := &quot;interface&quot; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="70"></a>(70)</font> &lt;export_decl&gt; := &quot;service&quot; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*
 
<font color="#FF0000"><a name="71"></a>(71)</font> &lt;observe_decl&gt; := &quot;observe&quot; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="72"></a>(72)</font> &lt;needs_decl&gt; := &quot;needs&quot; &lt;declarator&gt; { &quot;,&quot; &lt;declarator&gt; }*

<font color="#FF0000"><a name="73"></a>(73)</font> &lt;constants_decl&gt; := &quot;constants&quot; &lt;identifier&gt; &quot;{&quot; &lt;constant_decl&gt;+ &quot;}&quot;   
|    </b></pre>
    </td>
  </tr>
  <TR> 
    <TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699"> 
      <H3><A NAME="Basetypes"></A><FONT COLOR="#ffffff">Basetypes</FONT></H3>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
      <P>The unoidl supports the following basetypes:</P>
      <table width="100%" border="1">
        <tr> 
          <td><b>any</b></td>
          <td><b>boolean</b></td>
          <td><b>byte</b></td>
          <td><b>char</b></td>
          <td><b>double</b></td>
          <td><b>float</b></td>
          <td><b>hyper</b></td>
          <td><b>long</b></td>
        </tr>
        <tr> 
          <td><b>short</b></td>
          <td><b>string</b></td>
          <td><b>type</b></td>
          <td><b>void</b></td>
          <td><b>unsigned hyper</b></td>
          <td><b>unsigned long</b></td>
          <td><b>unsigned short</b></td>
          <td>&nbsp;</td>
        </tr>
      </table>
	  <P>The values <b>TRUE</b> and <b>FALSE</b> (<b>True</b> and <b>False</b>)
	  are defined for the <B><I>boolean</I></B> type. The type
	  <B><I>byte</I></B> is a 1 byte type and represents a type which is not
	  modified by the transport to another computer. The representation of the
	  type <B><I>char</I></B> can be different on a computer which
	  hardware/software architecture is different. It depends on the
	  representation of the used charset. The type <b>any</b> is a type which
	  can represent all possible idl types. The type <b>type</b> is a metatype
	  which describes other types defined in IDL.</P>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699"> 
      <H3><A NAME="Comments"></A><FONT COLOR="#ffffff">Comments</FONT></H3>
    </TD>
  </TR>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
	  <P>Comments are used to describe the source code. If the comment support
	  a special convention, it can be used for automatically generation of
	  documentation.  The unoidl support 4 kinds of comments:</P>
      <UL>
        <LI> 
          <p><b>/* comment */</b></p>
		  <p>All characters between /* and */ are ignored by the idl compiler.
		  The characters /* are also ignored, so encapsulated comments are not
		  allowed.</P>
        <LI> 
          <p><b>// comment end_of_line</b></p>
		  <p>With the characters // starts a comment which ends automatic at
		  the end of the line. All characters after // up to the end_ of_ line
		  character are ignored.</p>
        <LI> 
          <p><b>/** comment */</b></p>
		  <p>The characters /** shows that a special comment for automatic
		  documentation generation begins. This kind of comment will be saved
		  as a special documentation string by the compiler for the idl
		  definition which follow this comment.</p>
        <LI> 
          <p><b>/// comment</b></p>
		  <p>The characters /// shows that a special comment for automatic
		  documentation generation begins. All characters after /// up to the
		  end_ of_ line character are saved as a special documentation string
		  for the next valid idl definition.</p>
      </UL>
    </TD>
  </TR>
  <tr> 
    <td colspan=3 width=100% bgcolor="#666699"> 
      <h3><a name="Array"></a><font color="#FFFFFF">Array (not final, arrays can 
        not be used in UNO at this time)</font></h3>
    </td>
  </tr>
  <tr> 
    <td colspan=3 width=100%> 
      <p>Arrays are not final specified in the UNO IDL and can not be used with 
        UNO at this time!!!</p>
    </td>
  </tr>
  <tr> 
    <td colspan=3 width=100% bgcolor="#666699"> 
      <h3><a name="Union"></a><font color="#FFFFFF">Union (not final, unions can 
        not be used in UNO at this time)</font></h3>
    </td>
  </tr>
  <tr> 
    <td colspan=3 width=100%> 
      <p>Unions are not final specified in the UNO IDL and can not be used with 
        UNO at this time!!!</p>
    </td>
  </tr>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
      <HR SIZE=1 noshade>
    </TD>
  </TR>
  <TR> 
    <TD WIDTH=50% BGCOLOR="#666699"> 
      <P ALIGN=LEFT><FONT COLOR="#ffffff"> Author: <A HREF="mailto:juergen.schmidt@germany.sun.com"><FONT COLOR="#ffffff">J&uuml;rgen 
        Schmidt</FONT></A> ($Date: 2004/10/29 06:35:09 $)<BR>
        <I>Copyright 2001 Sun Microsystems, Inc., 901 San Antonio Road, Palo Alto, CA 94303 USA.</I></FONT> 
      </P>
    </TD>
  <TR> 
    <TD COLSPAN=3 WIDTH=100%> 
      <HR SIZE=1 noshade>
    </TD>
  </TR>
</TABLE>
</body>
</HTML>

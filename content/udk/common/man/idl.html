
<!--#include virtual="/doctype.html" -->
<html>
  <head>
    
    
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>Unoidl syntax description</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.2 (Win32)">
	<META NAME="CLASSIFICATION" CONTENT="Unoidl syntax description">
	<META NAME="KEYWORDS" CONTENT="UNO,Unoidl,syntax,description">

    
    <link href="/css/ooo.css" rel="stylesheet" type="text/css">
    <!--#include virtual="/scripts/google-analytics.js" --> 
    <!--#include virtual="/scripts/entourage.js" -->
  </head>
  <body LINK="#444488" VLINK="#444488" BGCOLOR="#eeeeff">
    <!--#include virtual="/brand.html" -->
    <div id="topbara">
      <!--#include virtual="/topnav.html" -->
      <div id="breadcrumbsa"><a href="/">home</a>&nbsp;&raquo;&nbsp;<a href="/udk/">udk</a>&nbsp;&raquo;&nbsp;<a href="/udk/common/">common</a>&nbsp;&raquo;&nbsp;<a href="/udk/common/man/">man</a></div>
    </div>
    <div id="clear"></div>
      
      
    <div id="content">
      
      
<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0 STYLE="page-break-before: always">
	<COL WIDTH=75>
	<TR>
		<TD BGCOLOR="#666699">
			<H1 ALIGN=CENTER STYLE="margin-top: 0cm; text-decoration: none"><A HREF="http://www.openoffice.org/"><IMG SRC="../../images/open_office_org_logo.gif" NAME="Grafik1" ALT="OpenOffice" ALIGN=RIGHT WIDTH=109 HEIGHT=54 BORDER=0></A><FONT COLOR="#ffffff"><FONT SIZE=6>Unoidl
			syntax description</FONT></FONT></H1>
		</TD>
	</TR>
</TABLE>
<HR SIZE=3 NOSHADE>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=61*>
	<COL WIDTH=162*>
	<COL WIDTH=32*>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3 ALIGN=LEFT STYLE="margin-top: 0cm; text-decoration: none"><FONT COLOR="#ffffff"><FONT SIZE=4>Contents</FONT></FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<A HREF="#Introduction">Introduction</A><BR>
			<A HREF="#Keywords">Keywords</A><BR>
			<A HREF="#Basetypes">Basetypes</A><BR>
			<A HREF="#Comments">Comments</A><BR>
			<A HREF="#Constants">Constants</A><BR>
			<A HREF="#Enumeration">Enumeration</A><BR>
			<A HREF="#Structure">Structure</A><BR>
			<A HREF="#Typedef">Typedef</A><BR>
			<A HREF="#Exception">Exception</A><BR>
			<A HREF="#Interface">Interface</A><BR>
			<A HREF="#Module">Module</A><BR>
			<A HREF="#Service">Service</A><BR>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3 ALIGN=LEFT STYLE="margin-top: 0cm; text-decoration: none"><A NAME="Introduction"></A>
			<FONT COLOR="#ffffff"><FONT SIZE=4>Introduction</FONT></FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P>The unoidl is an idl language (interface description language)
			which is similar to the corba idl. Idl is a language to describe
			interfaces and types independently of any programming language and
			hardware platform. An idl description is used by the idl compiler
			to generate code for these interfaces in a selected target
			language. The generated code provide the use of the described
			interfaces in the selected target language. The mapping of the idl
			description to the target language was defined in an appropriate
			language binding.
			</P>
			<P>All possible idl definitions will be described now. The reader
			who is intimate in C++ programming will see, that the syntax of
			the idl is similar to the C++ syntax. Because the lexical
			conventions of the idl and the structure of the definitions have a
			large degree with the ANSI standard for C++.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Keywords"></A><FONT COLOR="#ffffff">Keywords</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P>The following table shows all keywords of the unoidl. All the
			keywords are reserved and cannot be used as an identifier.</P>
		<TABLE WIDTH=100% BORDER=1 CELLPADDING=4 CELLSPACING=0>
					<COL WIDTH=43*>
					<COL WIDTH=43*>
					<COL WIDTH=43*>
					<COL WIDTH=43*>
					<COL WIDTH=43*>
					<COL WIDTH=43*>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>any</p>
						</TD>
						<TD WIDTH=17%>
							<p>attribute</p>
						</TD>
						<TD WIDTH=17%>
							<p>byte</p>
						</TD>
						<TD WIDTH=17%>
							<p>boolean</p>
						</TD>
						<TD WIDTH=17%>
							<p>char</p>
						</TD>
						<TD WIDTH=17%>
							<p>const</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>createAllListener</p>
						</TD>
						<TD WIDTH=17%>
							<p>double</p>
						</TD>
						<TD WIDTH=17%>
							<p>enum</p>
						</TD>
						<TD WIDTH=17%>
							<p>exception</p>
						</TD>
						<TD WIDTH=17%>
							<p>"FALSE"</p>
						</TD>
						<TD WIDTH=17%>
							<p>"False"</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>float</p>
						</TD>
						<TD WIDTH=17%>
							<p>getreflection</p>
						</TD>
						<TD WIDTH=17%>
							<p>hyper</p>
						</TD>
						<TD WIDTH=17%>
							<p>ident</p>
						</TD>
						<TD WIDTH=17%>
							<p>identifier</p>
						</TD>
						<TD WIDTH=17%>
							<p>in</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>includereflection</p>
						</TD>
						<TD WIDTH=17%>
							<p>inout</p>
						</TD>
						<TD WIDTH=17%>
							<p>interface</p>
						</TD>
						<TD WIDTH=17%>
							<p>language</p>
						</TD>
						<TD WIDTH=17%>
							<p>long</p>
						</TD>
						<TD WIDTH=17%>
							<p>map</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>mapping</p>
						</TD>
						<TD WIDTH=17%>
							<p>module</p>
						</TD>
						<TD WIDTH=17%>
							<p>name</p>
						</TD>
						<TD WIDTH=17%>
							<p>needs</p>
						</TD>
						<TD WIDTH=17%>
							<p>object</p>
						</TD>
						<TD WIDTH=17%>
							<p>observes</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>optional</p>
						</TD>
						<TD WIDTH=17%>
							<p>out</p>
						</TD>
						<TD WIDTH=17%>
							<p>property</p>
						</TD>
						<TD WIDTH=17%>
							<p>raises</p>
						</TD>
						<TD WIDTH=17%>
							<p>readonly</p>
						</TD>
						<TD WIDTH=17%>
							<p>service</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>sequence</p>
						</TD>
						<TD WIDTH=17%>
							<p>short</p>
						</TD>
						<TD WIDTH=17%>
							<p>string</p>
						</TD>
						<TD WIDTH=17%>
							<p>struct</p>
						</TD>
						<TD WIDTH=17%>
							<p>"TRUE"</p>
						</TD>
						<TD WIDTH=17%>
							<p>"True"</p>
						</TD>
					</TR>
					<TR VALIGN=TOP>
						<TD WIDTH=17%>
							<p>typedef</p>
						</TD>
						<TD WIDTH=17%>
							<p>uik</p>
						</TD>
						<TD WIDTH=17%>
							<p>unsigned</p>
						</TD>
						<TD WIDTH=17%>
							<p>version</p>
						</TD>
						<TD WIDTH=17%>
							<p>virtual</p>
						</TD>
						<TD WIDTH=17%>
							<p>void</p>
						</TD>
					</TR>
				</TABLE>
				<BR>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Basetypes"></A><FONT COLOR="#ffffff">Basetypes</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P>The unoidl support the following basetypes:</P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>any,
				boolean, byte, char, double, float, hyper, long, short, string,
				void, unsigned hyper, unsigned long, unsigned short</CODE>
				</DD>
			</DL>
			<P>The values TRUE and
			FALSE (True and False) are defined for the <B><I>boolean</I></B>
			type. The type <B><I>byte</I></B> is
			a 1 byte type and represents a type which is not modified by the
			transport to another computer. The representation of the type <B><I>char</I></B>
			can be different on a computer which hardware/software
			architecture is different. It depends on the representation of the
			used charset. The type any is a type which can represent all
			possible idl types.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Comments"></A><FONT COLOR="#ffffff">Comments</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P>Comments are used to describe the source code. If the comment
			support a special convention, it can be used for automatically
			generation of documentation. The unoidl support 4 kinds of
			comments:</P>
			<UL>
				<li><p><b>/* comment */</b></p>
				<p>All characters between /* and */ are ignored by the idl
				compiler. The characters /* are also ignored, so encapsulated
				comments (comments in comments) are not allowed.</P>
				<li><p><b>// comment end_of_line</b></p>
				<p>With the characters // starts a comment which ends automatic
				at the end of the line. All characters after // up to the end_
				of_ line character are ignored.</P>
				<li><p><b>/** comment */</b></p>
				<p>The characters /** shows that a special comment for automatic
				documentation generation begins. This kind of comment will be
				saved as a special documentation string by the compiler for the
				idl definition which follow this comment.</P>
				<li><p><b>/// comment</b></p>
				<p>The characters /// shows that a special comment for automatic
				documentation generation begins. All characters after /// up to
				the end_ of_ line character are saved as a special
				documentation string for the next valid idl definition.</P>
			</UL>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Constants"></A><FONT COLOR="#ffffff">Constants</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>const
				&lt;TypeName&gt; &lt;ConstantName&gt; "=" &lt;Value&gt;
				";"</CODE></DD></DL>
			<P>
			A constant definition begin with the keyword <B><I>const</I></B>
			following by the identifier of a type (base_type), the identifier
			of the constant and the assignment of a value. The value must be
			in the range of the used type. The definition ends with a
			semicolon. It is also possible to assign an expression. You can
			combine values/expressions of the type [unsigned] hyper| long |
			short with the operators *, /, %, +, -, &lt;&lt;, &gt;&gt;, &amp;,
			^ and | which are known of C++.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Enumeration"></A><FONT COLOR="#ffffff">Enumeration</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>enum
				&lt;EnumName&gt; "{" &lt;EnumValue&gt; [= Value] { ","
				&lt;EnumValue&gt; [= Value] }* "}" ";"</CODE></DD></DL>
			<P>
			An enumeration definition begin with the keyword <B><I>enum</I></B>
			following by the identifier of the enumeration type. The body of
			the definition is bound with { } and the complete definition ends
			with a semicolon. The body exists of an ordered list of
			identifiers. It is possible to assign such an identifier a value
			of the type long. The default numbering of the values is linear
			and begin with 0 and crows with 1. If an identifier has an value,
			all following identifiers without a value are numbered depending
			on these last assignment of a value. All enum values of the body
			are also known in the scope of enumeration type itself.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Structure"></A><FONT COLOR="#ffffff">Structure</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>struct
				&lt;StructureName&gt; [ ":" &lt;ExistStructureName&gt;
				]<BR>"{"<BR>{ &lt;ElementType&gt; &lt;ElementName&gt;
				";" }+<BR>"}" ";"</CODE></DD></DL>
			<P>
			The definition of a structure begins with the keyword <B><I>struct</I></B>
			following by the identifier of the structure. The body of the
			definition is bound with { } and the complete definition ends with
			a semicolon. Inside the body it is possible to define some
			elements. An element definition begins with the identifier of the
			type following by the identifier of the element name. The
			definition end with a semicolon. The body of the structure is a
			new namespace. Inside this namespace it is possible to use all
			identifiers as names which are definite. It is possible to define
			an inheritance for the structure. An inheritance will be defined
			after the name identifier by a colon following an identifier of
			the parent structure. Inheritance of structures is UNO specific
			and not CORBA compatible.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Typedef"></A><FONT COLOR="#ffffff">Typedef</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>typedef
				&lt;TypeName&gt; &lt;NewTypeName&gt; ";"</CODE></DD></DL>
			<P>
			A type definition begins with the keyword <B><I>typedef
			</I></B>following by an identifier of an existing type and
			the identifier of the new type. The definitions ends with a
			semicolon</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Exception"></A><FONT COLOR="#ffffff">Exception</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>exception
				&lt;ExceptionName&gt; [ ":" &lt;ExistExceptionName&gt; ]<BR>
				"{"<BR>
				{ &lt;ElementType&gt; &lt;ElementName&gt; ";" }*<BR>
				"}" ";"</CODE></DD></DL>
			<P>
			The definition of an exception begins with the keyword <B><I>exception</I></B>
			following by the identifier of the exception. The body of the
			definition is bound with { } and the complete definition ends with
			a semicolon. Inside the body it is possible to define some
			members. A member definition begins with the identifier of the
			type following by the identifier of the member name. The
			definition end with a semicolon. The body of the structure is a
			new namespace. Inside this namespace it is possible to use all
			identifiers as names which are definite. It is possible to define
			an inheritance for the exception. An inheritance will be defined
			after the name identifier by a colon following an identifier of
			the parent exception. Inheritance of exceptions is UNO specific
			and not CORBA compatible.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Interface"></A><FONT COLOR="#ffffff">Interface</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>"["
				uik"("&lt;Uik&gt;")""," ident"("
				"\""&lt;InterfaceName&gt;"\"" ","
				&lt;VersionNummer&gt;")" "]"<BR>
				interface
				&lt;InterfaceName&gt; [ ":" &lt;InterfaceName&gt; {,
				&lt;InterfaceName&gt;}* ] <BR>
				"{"<BR>
				{ &lt;typedef&gt;
				| &lt;struct&gt; | &lt;exception&gt; | &lt;constant&gt; |
				&lt;enumeration&gt; | &lt;interface&gt;}* { "["
				[readonly ","] attribute "]" &lt;TypeName&gt;
				&lt;AttributeName&gt; { "," &lt;AttributeName&gt;}* ";"
				}*<BR>
				{ [ "["const | oneway "]" ] &lt;TypeName&gt;
				&lt;FunctionName&gt; "(" [ &lt;Parameter&gt; { ","
				&lt;Parameter&gt;}* ] ")" [ &lt;Raises&gt; ] ";"
				}*<BR>
				"}" ";"<BR>
				<BR>
				&lt;Uik&gt; =
				xxxxxxxx-xxxx-xxxx-xxxxxxxx-xxxxxxxx ; x &Icirc;{0-9a-fA-F}<BR>
				&lt;Parameter&gt;
				= "[" in | out | inout "]" &lt;TypeName&gt;
				&lt;ParameterName&gt;<BR>
				&lt;Raises&gt; = raises"("
				&lt;ExceptionName&gt; { "," &lt;ExceptionName&gt;}* ")"</CODE>
				</DD>
			</DL>
			<P>
			An interface definition begins with an header which is bound with
			[ ]. The header consists of an uik (universal interface key)
			definition and an ident definition. The definition begins with the
			keyword <B><I>uik</I></B> following
			by a 32 byte number which is split in 5 blocks (8-4-4-8-8 byte)
			and bound in ( ). The ident definition begins with the keyword
			<B><I>ident</I></B> following by the
			name of the interface and a version number. After the header
			follows the keyword interfaces and an identifier for the interface
			name. Optionally, an inheritance definition can follow. An
			inheritance definition begins with a colon and one or more
			identifiers of existing interfaces. The body of the interface is
			bound with { } and the definition ends with a semicolon.<BR>An
			interface opens a new namespace. There can be defined <A HREF="#Typedef">typedefs</A>,
			<A HREF="#Structure">structs</A>, <A HREF="#Enumeration">enums</A>,
			<A HREF="#Exception">exceptions</A>, <A HREF="#Constants">constants</A>
			and <A HREF="#Interface">interfaces</A> and also specific
			definitions for an interface:</P>
			<UL>
				<LI><P><CODE>"["
				[readonly "," ] attribute "]" &lt;TypeName&gt;
				&lt;AttributeName&gt; { "," &lt;AttributeName&gt;}*
				";"</CODE><BR>
				An
				attribute definition begins with a header which is bound with [
				]. In this header the keyword <B><I>attribute</I></B>
				must be defined. Optional the keyword <B><I>readonly</I></B>
				defined that the attribute can only accessed for reading. The
				header follows an identifier for the attribute type and an
				identifier for the attribute name or a list of identifiers. The
				definition ends with a semicolon.</P>
			</UL>
			<UL>
				<LI><P><CODE>"["const
				| oneway "]" ] &lt;TypeName&gt; &lt;FunctionName&gt;
				"(" [ &lt;Parameter&gt; { "," &lt;Parameter&gt;}*
				] ")" [ &lt;Raises&gt; ] ";"</CODE><BR>
				A
				function definition begins with an optional header following by
				an identifier for the return type and an identifier for the
				function name. The header is bound with [ ] and consists of the
				flags <B><I>oneway</I></B> or <B><I>const</I></B>
				or both. Oneway means that the function is asynchronous and don`t
				wait for a reply. To use this flag the function must return void,
				don`t take any out or inout parameters and don`t raise an
				exception. Const means that the function don`t change the state
				of the interface. The name of the function follows a parameter
				definition which is bound in ( ) and a raises expression which is
				optional.
				</P>
				<LI><P><CODE>&lt;Parameter&gt;
				= "[" in | out | inout "]" &lt;TypeName&gt;
				&lt;ParameterName&gt;</CODE><BR>
				The
				parameter definition begins with the direction flag which is
				bound with [ ]. Valid flags for the direction are <B><I>in</I></B>
				( in parameter), <B><I>out</I></B>
				(out parameter) or <B><I>inout</I></B>
				(in and out parameter). The direction follows an identifier for
				the parameter type and an identifier for the parameter name. More
				than one parameter definitions are separated by comma.</P>
				<LI><P><CODE>&lt;Raises&gt;
				= raises"(" &lt;ExceptionName&gt; { ","
				&lt;ExceptionName&gt;}* ")"</CODE><BR>
				The
				raises definition begins with the keyword raises following by one
				or more identifiers of existing exceptions which are bound with (
				). This named exceptions can be raised during the execution of
				the function.</P>
			</UL>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Module"></A><FONT COLOR="#ffffff">Module</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>module
				&lt;ModuleName&gt;<BR>
				"{"<BR>
				{ &lt;typedef&gt; |
				&lt;struct&gt; | &lt;exception&gt; | &lt;constant&gt; |
				&lt;enumeration&gt; | &lt;interface&gt; | &lt;module&gt; }*<BR>
				"}" ";"
				</CODE></DD>
			</DL>
			<P>
			A module definition begins with the keyword <B><I>module</I></B>
			following by the identifier of the module. The body of the
			definition is bound with { } and the complete definition ends with
			a semicolon. A module opens a new namespace and there can be
			defined all valid idl definitions.</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100% BGCOLOR="#666699">
			<H3><A NAME="Service"></A><FONT COLOR="#ffffff">Service</FONT></H3>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<P><I>Definition:</I></P>
			<DL>
				<DD STYLE="margin-bottom: 0.51cm"><CODE>service
				&lt;ServiceName&gt;<BR>
				"{"<BR>
				{ "[" [readonly
				"," ] property "]" &lt;TypeName&gt;
				&lt;PropertyName&gt; { "," &lt;PropertyName&gt;}* ";"
				}*<BR>
				{ interface &lt;InterfaceName&gt; { ","
				&lt;InterfaceName&gt; }* ";" }*<BR>
				{ observes
				&lt;InterfaceName&gt; { "," &lt;InterfaceName&gt; }*
				";" }*<BR>
				{ needs &lt;ServiceName&gt; { ","
				&lt;ServiceName&gt; }* ";" }*<BR>
				"}" ";"
				</CODE></DD>
			</DL>
			<P>
			A service definition begins with the keyword <B><I>service</I></B>
			following by an identifier for the name of the service. Services
			are principally for description and are UNO specific. The body of
			the definition is bound with { } and the complete definition ends
			with a semicolon.<BR>Definitions in a service:</P>
			<UL>
				<LI><P><CODE>"["
				[readonly "," ] property "]" &lt;TypeName&gt;
				&lt;PropertyName&gt; { "," &lt;PropertyName&gt;}* ";"
				</CODE>
				<A HREF="#object_property_def">(see object property 
				definition)</A></p>
				<p> A <i>property</i> definition begins with a header which is
				bound with [ ].  In this header the keyword
				<B><I>property</I></B> must be defined. Optional the keyword
				<B><I>readonly</I></B> defined that the property can only
				accessed for reading. The header follows an identifier for the
				property type and an identifier for the property name or a list
				of identifiers. The definition ends with a semicolon.</P>
				<LI><P><CODE>interface
				&lt;InterfaceName&gt; { "," &lt;InterfaceName&gt; }*
				";"</CODE> <A HREF="#object_interface_def">(see
				object interface definition)</A></p>
				<p>An <i>interface</i> definition begins with the keyword
				<B><I>interface</I></B> following by an identifier of an
				existing interface or a list of identifiers of existing
				interfaces. This definition in the scope of a service means
				that the service provides the named interfaces. The definition
				ends with a semicolon.</P>
			</UL>
			<UL>
				<LI><P><CODE>observes
				&lt;InterfaceName&gt; { "," &lt;interfaceName&gt; }*
				";"</CODE> <A HREF="#object_observes_def">(see
				object observes definition)</A></p>
				<p>An <i>observes</i> definition begins with the keyword
				<B><I>observes</I></B> following by an identifier of an
				existing interface or a list of identifiers of existing
				interfaces. This definition in the scope of a service means
				that the service must observe the named interfaces. The
				definition ends with a semicolon.</P>
				<LI><P><CODE>needs
				&lt;ServiceName&gt; { "," &lt;ServiceName&gt; }* ";"</CODE>
				<A HREF="#object_needs_def">(see
				object needs definition)</A></p>
				<p>A <i>needs</i> definition begins with the keyword
				<B><I>needs</I></B> following by an identifier of an existing
				service or a list of identifiers of existing services. This
				definition in the scope of a service means that the service
				needs the named services. The definition ends with a
				semicolon.</P>
			</UL>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<HR SIZE=1 NOSHADE>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=50% BGCOLOR="#666699">
			<P ALIGN=LEFT><FONT COLOR="#ffffff">
			Author: <A HREF="mailto:juergen.schmidt@germany.sun.com"><FONT COLOR="#ffffff">J&uuml;rgen Schmidt</FONT></A> ($Date: 2004/10/29 02:01:05 $)<BR>
			<I>Copyright 2001 Sun Microsystems, Inc., 901 San Antonio Road, Palo Alto, CA 94303 USA.</I></FONT>
			</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3 WIDTH=100%>
			<HR SIZE=1 NOSHADE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=3 NOSHADE>

      
    </div>
    <!--#include virtual="/footer.html" -->
  </body>
</html>
